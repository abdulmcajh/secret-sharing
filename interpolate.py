import randomimport sysclass INTERPOLATE: #Class that interpolates points given a python dictionary to find an intercept	  def __init__(self,field,points):    self.field = field #field in which operations are performed    self.points = points #interpolation will be performed using these points    self.x = self.points.keys() #abscissas     self.y = self.points.values() #ordinates    self.number = len(self.x) #how many points were supplied		  def ascii(self,b):  #Converts binary string into ascii character    S = chr(int(b,2))    return S		  def imod(self,x,n):  #Calculates modular inverse of x in the field         return self.eea(x, n)[0] % n		  def eea(self,u, v):  #Extended Euclidean Algorithm (used to calculate modular inverses)    u1 = 1    u2 = 0    u3 = u    v1 = 0    v2 = 1    v3 = v    ls = []    while v3 != 0:      q = u3 / v3      ls.append(q)      t1 = u1 - q * v1      t2 = u2 - q * v2      t3 = u3 - q * v3      u1 = v1      u2 = v2      u3 = v3      v1 = t1      v2 = t2      v3 = t3    return u1, u2, u3, ls		  def lagrange(self):  #Lagrange interpolation to find the y-intercept    secret = 0        def lbasis(j): #this function is used is part of langrange interpolation      l = 1      for m in xrange(self.number):        if m!= j:          l *= (0-int(self.x[m])) * self.imod((int(self.x[j]) - int(self.x[m])),self.field) % self.field      return l		    for point in xrange(self.number):      secret +=  int(self.y[point],16) * lbasis(point) % self.field      secret = secret % self.field      bin_secret = bin(secret)[2:] #convert secret to binomial      ascii_secret = self.ascii(bin_secret) #convert secret to ascii          return ascii_secret