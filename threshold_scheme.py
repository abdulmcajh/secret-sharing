import randomimport sysimport argparsefrom secret import SECRETfrom interpolate import INTERPOLATE	def rand_prime(n):   #generate random prime one bit greater than number n		bits = len(bin(n))-1 #number of bits of number n, plus one. (this is because binary representation starts with 0b)		ok = 0		while ok is 0:			p = random.randrange(pow(2, bits - 1), pow(2, bits) - 1, 2) - 1   #random odd number			ok = miller_rabin(p, 10)                     #check primality		return p					def miller_rabin(number, tries): #miller_rabin test for primality        		s = 0                                       		d = number - 1		while 1:			if d % 2 == 0:				s += 1				d = d / 2			else:				break		for _ in range(1, tries):			ok = 0			a = random.randint(2, number - 2)			x = pow(a, d, number)			if x == 1 or x == number - 1:				continue			else:				for _ in range(1, s - 1):					x = pow(x, 2, number)					if x == 1:						return 0					if x == number - 1:						ok = 1						break				if (ok == 0):					return 0				else:					continue		return 1							def dist_shares(k,n,secret):	'''	Method to distribute n shares based on the secret and number k required to assemble	'''	field = 257 #default field size	shares = {} #share in dictionary format		if n > 257:			field = rand_prime(n) #select a random prime greater than n		field_hex = hex(field)[2:] #field in hex format	for i in xrange(n): shares[i+1]=str(k)+'|'+field_hex+'|' #share format is <number-required|field_size|share>		for char in xrange(len(secret)): #for every character in the secret		sub_secret = SECRET(k,n,field,secret[char]) #use Secret class		points = sub_secret.create_points() #generate shares for this character				for i in xrange(n):			x = i+1			temp = str(hex(points[x]))[2:] #convert point values to hex			if len(temp) == len(field_hex):				shares[x]+=temp #concatenate character point to each share			else:					shares[x]+=temp + (len(field_hex)-len(temp))*'#'			return shares						def recover_secret(input):	'''	Method to recover secret based on provided shares	'''	shares = {}	points = {}	final_secret = ''			for item in input: #in each share		share_index = item.find('-') #delimiter for share number		req_index = item.find('|') #delimiter for required number of shares		field_index = item.find('|',req_index+1) #delimiter for field value		if int(item[share_index+1:req_index]) > len(input): 			print 'Need more shares to recover!'			return 1						shares[int(item[0:share_index])] = item[field_index+1:]		field = item[req_index+1:field_index]	word_size = len(str(field))		secret_length = len(shares.values()[0])/word_size			for i in xrange(secret_length):		index = i*word_size		for x in shares.keys():			temp = shares[x][index:index+word_size]			points[x]=temp.strip('#')					ASCII = INTERPOLATE(int(field,16),points)		secret = ASCII.lagrange()				final_secret+=secret				return final_secret		def main():	'''	Allows to be used as command line.  There's also a GUI that is more convenient to use	'''		parser = argparse.ArgumentParser(description='Threshold Secret Sharing', usage = 'threshold_scheme.py [options]')	subparsers = parser.add_subparsers(title = 'subcommands', dest = 'action')		parser_create = subparsers.add_parser('generate', help = 'Generates new shares. Input filename with required, total and secret in separate lines. Result is in out.txt')	parser_create.add_argument('filename')	parser_create.add_argument('-o','--result', help='File where shares will be saved to',required=True)			parser_recover = subparsers.add_parser('recover', help = 'Recover the secret.  Input filename with shares and output filename')	parser_recover.add_argument('filename')	parser_recover.add_argument('-o','--result', help='File where recovered secret will be saved to',required=True)			args = parser.parse_args()		if args.action == 'generate':			inputs = [line.strip() for line in open(args.filename)]			k = int(inputs[0])			n = int(inputs[1])			secret = inputs[2]			shares = dist_shares(k,n,secret)			with open(args.result,'w') as output:				for share in shares:		 			output.write("%d-%s" % (share,shares[share])+'\n')			output.close()						elif args.action == 'recover':			shares = [line.strip() for line in open(args.filename)]			secret=recover_secret(shares)			with open(args.result,'w') as output:				output.write(secret)			output.close()	else:		usage()		  if __name__ == "__main__":	main()	